@inject IReadOnlyStateFactory<States> StateFactory
@using Economy.Implementation.Factories
@using Economy.Memory.Containers.State
@model (Economy.Web.Pages.BranchesModel branchesModel, int branchId)

@{
    var states = await StateFactory.GetState();
    var branch = states.Branches[Model.branchId];
    var isCurrent = states.Current.branch == branch || states.Current.detachedFrom == branch;
}

<li>
    <span class="record @(isCurrent ? "current" : null)">@branch.Id. @branch.Status: <a asp-page="/History" asp-all-route-data='@(new Dictionary<string, string> { ["branchId"] = branch.Id.ToString() })'>@(branch.Name ?? "no name")</a></span>
    <span>@states.BranchStates[branch.Id].Events.LastOrDefault()?.CreatedOn</span>
    @if (states.Current.detachedFrom != null && isCurrent)
    {
        <span>(detached)</span>
    }
    
    @if (states.GetChildBranchIds(Model.branchId).Any())
    {
        <ul>
            @foreach (var childBranchId in states.GetChildBranchIds(Model.branchId).OrderBy<int, long>(Model.branchesModel.Ordering switch
                      {
                          BranchesModel.BranchesOrdering.Id => x => x,
                          BranchesModel.BranchesOrdering.IdDesc => x => -x,
                          BranchesModel.BranchesOrdering.Date => x => (states.BranchStates[x].Events.LastOrDefault()?.CreatedOn ?? DateTime.MinValue).Ticks,
                          BranchesModel.BranchesOrdering.DateDesc => x => (DateTime.MaxValue - states.BranchStates[x].Events.LastOrDefault()?.CreatedOn)?.Ticks ?? 0,
                          _ => throw new ArgumentOutOfRangeException()
                      }))
            {
                <partial name="Dynamic/DynamicBranches.Branch" model="(Model.branchesModel, childBranchId)" />
            }
        </ul>
    }
</li>