@using Economy.Engine
@using Economy.Memory.Containers.State
@using Economy.Web.Tools
@model Report1Model.MatchBase
@inject StateFactory<State> StateFactory

@{
    var state = await StateFactory.GetState();
}

@switch (Model)
{
    case Report1Model.PlannedAndActualMatch match:
        <span>@Constants.Actual @match.Actual.Amounts.ToDetails(state.Repositories) / @Constants.Plan @match.Planned.Amounts.ToDetails(state.Repositories)</span>
        break;
    case Report1Model.ScheduleAndActualMatch match:
        <span>@Constants.Actual @match.Actual.Amounts.ToDetails(state.Repositories) / @match.TotalSchedulePlanned.ToDetails(state.Repositories)</span>
        break;
    case Report1Model.ScheduleRemainderMatch match:
        if (match.IsFull)
        {
            <span>@Constants.Schedule @match.Plan.Schedule!.Amounts.ToDetails(state.Repositories)</span>
        }
        else
        {
            <span>@Constants.Remainder @match.Remainder.ToDetails() / @Constants.Schedule @match.Plan.Schedule!.Amounts.ToDetails(state.Repositories)</span>
        }
        break;
    case Report1Model.ActualMatch match:
        <span>@Constants.Actual @match.Actual.Amounts.ToDetails(state.Repositories)</span>
        break;
    case Report1Model.PlannedMatch match:
        <span>@Constants.Plan @match.Planned.Amounts.ToDetails(state.Repositories)</span>
        break;
    case Report1Model.PlannedRemainderMatch match:
        <span>@Constants.Remainder @match.Remainder.ToDetails(state.Repositories) / @Constants.Plan @match.Planned.Amounts.ToDetails(state.Repositories)</span>
        break;
    case Report1Model.ExternalMatch match:
        <span>@(match.IsOutgoing ? "" : Constants.Minus)@match.Transfer.Amount.ToDetails(state.Repositories)</span>
        break;
}

<span>@Model.ToDetailsNoAmountsOrType(state.Repositories)</span>