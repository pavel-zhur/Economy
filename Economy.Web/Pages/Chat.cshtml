@page
@model ChatModel
@{
    ViewData["Title"] = "Chat";
}

<h2>Chat Application</h2>

<div id="connectionStatus">Status: <span id="statusText">Disconnected</span></div>

<div id="chatsContainer"></div>

<div id="newChatContainer">
    <button id="newChatButton">Start New Chat</button>
</div>

@section Scripts {
    <script>
        (() => {
            const connectionStatusText = document.getElementById('statusText');
            const chatsContainer = document.getElementById('chatsContainer');
            const newChatButton = document.getElementById('newChatButton');

            let chats = {}; // Stores chat data with randomChatId as the key
            let connection;

            // Global error handlers
            window.onerror = function(message, source, lineno, colno, error) {
                console.error(`Global Error: ${message} at ${source}:${lineno}:${colno}`, error);
            };

            window.onunhandledrejection = function(event) {
                console.error('Unhandled Promise Rejection:', event.reason);
            };

            const initializeConnection = () => {
                try {
                    connection = new signalR.HubConnectionBuilder()
                        .withUrl("/chathub")
                        .withHubProtocol(new signalR.protocols.msgpack.MessagePackHubProtocol())
                        .withAutomaticReconnect({
                            nextRetryDelayInMilliseconds: retryContext => {
                                if (retryContext.elapsedMilliseconds < 60000) {
                                    // Wait between 0 and 3 seconds before the next reconnect attempt.
                                    return Math.random() * 3000;
                                } else {
                                    // Stop reconnecting after 60 seconds
                                    return null;
                                }
                            }
                        })
                        .configureLogging(signalR.LogLevel.Information)
                        .build();

                    // Event handlers
                    connection.onclose(error => {
                        try {
                            updateConnectionStatus('Disconnected');
                            disableInputs(true);
                            logError('Connection closed', error);
                        } catch (err) {
                            console.error('Error in onclose handler:', err);
                        }
                    });

                    connection.onreconnecting(error => {
                        try {
                            updateConnectionStatus('Reconnecting');
                            disableInputs(true);
                            logError('Connection reconnecting', error);
                        } catch (err) {
                            console.error('Error in onreconnecting handler:', err);
                        }
                    });

                    connection.onreconnected(connectionId => {
                        try {
                            updateConnectionStatus('Connected');
                            disableInputs(false);
                            sendHello();
                            logInfo('Reconnected with connectionId:', connectionId);
                        } catch (err) {
                            console.error('Error in onreconnected handler:', err);
                        }
                    });

                    connection.on('HelloResponse', state => {
                        try {
                            handleHelloResponse(state);
                        } catch (err) {
                            console.error('Error in HelloResponse handler:', err);
                        }
                    });

                    connection.on('Authenticate', () => {
                        try {
                            // Server demands reauthentication; reload the page
                            location.reload();
                        } catch (err) {
                            console.error('Error in Authenticate handler:', err);
                        }
                    });

                    // Start the connection
                    updateConnectionStatus('Reconnecting');
                    connection.start()
                        .then(() => {
                            updateConnectionStatus('Connected');
                            disableInputs(false);
                            console.info('SignalR connection established.');
                            sendHello();
                        })
                        .catch(err => {
                            console.error('Connection error:', err.toString());
                        });
                } catch (err) {
                    console.error('Error initializing SignalR connection:', err);
                }
            };

            const updateConnectionStatus = (status) => {
                try {
                    connectionStatusText.textContent = status;
                    const statusClass = status.toLowerCase();
                    connectionStatusText.className = ''; // Reset classes
                    connectionStatusText.classList.add(statusClass);
                } catch (err) {
                    console.error('Error updating connection status:', err);
                }
            };

            const sendHello = () => {
                connection.invoke('Hello')
                    .catch(err => {
                        console.error('Error sending Hello:', err.toString());
                    });
            };

            const disableInputs = (disabled) => {
                try {
                    const sendButtons = document.querySelectorAll('.sendButton');
                    const micButtons = document.querySelectorAll('.micButton');
                    sendButtons.forEach(button => button.disabled = disabled);
                    micButtons.forEach(button => button.disabled = disabled);
                } catch (err) {
                    console.error('Error disabling inputs:', err);
                }
            };

            const handleHelloResponse = (state) => {
                try {
                    // Overwrite all chats with the state received from the server
                    chats = {};
                    state.chats.forEach(chatModel => {
                        chats[chatModel.randomChatId] = chatModel;
                    });
                    renderChats();
                } catch (err) {
                    console.error('Error handling HelloResponse:', err);
                }
            };

            const renderChats = () => {
                try {
                    // Clear existing chats
                    chatsContainer.innerHTML = '';
                    Object.values(chats).forEach(chatModel => {
                        renderChat(chatModel);
                    });
                } catch (err) {
                    console.error('Error rendering chats:', err);
                }
            };

            const renderChat = (chatModel) => {
                try {
                    let chatDiv = document.getElementById(`chat-${chatModel.randomChatId}`);
                    if (!chatDiv) {
                        chatDiv = document.createElement('div');
                        chatDiv.id = `chat-${chatModel.randomChatId}`;
                        chatDiv.classList.add('chat');

                        const chatHeader = document.createElement('h3');
                        chatHeader.textContent = `Chat ${chatModel.randomChatId}`;
                        chatDiv.appendChild(chatHeader);

                        const messagesList = document.createElement('ul');
                        messagesList.id = `messagesList-${chatModel.randomChatId}`;
                        chatDiv.appendChild(messagesList);

                        const messageInput = document.createElement('input');
                        messageInput.type = 'text';
                        messageInput.placeholder = 'Type a message...';
                        messageInput.classList.add('messageInput');
                        messageInput.id = `messageInput-${chatModel.randomChatId}`;
                        chatDiv.appendChild(messageInput);

                        const sendButton = document.createElement('button');
                        sendButton.textContent = 'Send';
                        sendButton.classList.add('sendButton');
                        sendButton.id = `sendButton-${chatModel.randomChatId}`;
                        sendButton.addEventListener('click', () => {
                            try {
                                sendMessage(chatModel.randomChatId);
                            } catch (err) {
                                console.error('Error in sendButton click handler:', err);
                            }
                        });
                        chatDiv.appendChild(sendButton);

                        const micButton = document.createElement('button');
                        micButton.innerHTML = '<i class="fa fa-microphone"></i>';
                        micButton.classList.add('micButton');
                        micButton.id = `micButton-${chatModel.randomChatId}`;
                        micButton.addEventListener('click', () => {
                            try {
                                startVoiceRecording(chatModel.randomChatId);
                            } catch (err) {
                                console.error('Error in micButton click handler:', err);
                            }
                        });
                        chatDiv.appendChild(micButton);

                        const closeChatButton = document.createElement('button');
                        closeChatButton.textContent = 'Close Chat';
                        closeChatButton.addEventListener('click', () => {
                            try {
                                closeChat(chatModel.randomChatId);
                            } catch (err) {
                                console.error('Error in closeChatButton click handler:', err);
                            }
                        });
                        chatDiv.appendChild(closeChatButton);

                        chatsContainer.appendChild(chatDiv);
                    }

                    updateChatUI(chatModel);
                } catch (err) {
                    console.error('Error rendering a chat:', err);
                }
            };

            const updateChatUI = (chatModel) => {
                try {
                    const messagesList = document.getElementById(`messagesList-${chatModel.randomChatId}`);
                    if (messagesList) {
                        messagesList.innerHTML = '';
                        chatModel.messages.forEach(message => {
                            const li = document.createElement('li');
                            li.textContent = formatMessage(message);

                            // Add cancel button for user's message if cancellation is possible
                            if (message.type === 'UserText' || message.type === 'UserVoice') {
                                if (message.status === 'Thinking') {
                                    const cancelButton = document.createElement('button');
                                    cancelButton.textContent = 'Cancel';
                                    cancelButton.addEventListener('click', () => {
                                        try {
                                            tryCancelMessage(chatModel.randomChatId, message.randomMessageId);
                                        } catch (err) {
                                            console.error('Error in cancel button click handler:', err);
                                        }
                                    });
                                    li.appendChild(cancelButton);
                                }
                            }

                            messagesList.appendChild(li);
                        });
                        messagesList.scrollTop = messagesList.scrollHeight;
                    }

                    // Enable or disable inputs based on chat status
                    const sendButton = document.getElementById(`sendButton-${chatModel.randomChatId}`);
                    const micButton = document.getElementById(`micButton-${chatModel.randomChatId}`);
                    const isDisabled = (chatModel.status !== 'Success' && chatModel.status !== 'Processing');
                    if (sendButton) sendButton.disabled = isDisabled;
                    if (micButton) micButton.disabled = isDisabled;
                } catch (err) {
                    console.error('Error updating chat UI:', err);
                }
            };

            const formatMessage = (message) => {
                try {
                    let msgText = '';
                    if (message.type === 'UserText' || message.type === 'UserVoice') {
                        msgText = `You: ${message.text}`;
                    } else if (message.type === 'ServerText') {
                        msgText = `Server: ${message.text}`;
                    } else if (message.type === 'SystemText') {
                        msgText = `[${message.systemMessageSeverity}] ${message.text}`;
                    } else if (message.type === 'ActionLog') {
                        msgText = `${message.text}`;
                    }
                    return msgText;
                } catch (err) {
                    console.error('Error formatting message:', err);
                    return 'Invalid message format';
                }
            };

            const sendMessage = (randomChatId) => {
                try {
                    const messageInput = document.getElementById(`messageInput-${randomChatId}`);
                    const messageText = messageInput.value.trim();
                    if (messageText === '') return;

                    const randomMessageId = generateRandomId();

                    // Optimistically add message to chat
                    const messageModel = {
                        timestamp: new Date().toISOString(),
                        type: 'UserText',
                        randomMessageId: randomMessageId,
                        text: messageText,
                        status: 'Thinking',
                        systemMessageSeverity: null
                    };

                    // If the chat is closed or doesn't exist, create a new chat
                    if (!chats[randomChatId]) {
                        chats[randomChatId] = {
                            randomChatId: randomChatId,
                            messages: [],
                            status: 'Processing'
                        };
                    }

                    chats[randomChatId].messages.push(messageModel);
                    renderChat(chats[randomChatId]);

                    // Send the message to the server
                    connection.invoke('SendMessage', randomChatId, randomMessageId, messageText)
                        .catch(err => {
                            console.error('SendMessage error:', err.toString());
                        });

                    messageInput.value = '';
                } catch (err) {
                    console.error('Error in sendMessage:', err);
                }
            };

            const startVoiceRecording = async (randomChatId) => {
                try {
                    // Start voice recording
                    const audioBlob = await recordAudio();
                    const randomMessageId = generateRandomId();

                    // Optimistically add message to chat
                    const messageModel = {
                        timestamp: new Date().toISOString(),
                        type: 'UserVoice',
                        randomMessageId: randomMessageId,
                        text: "(...)",
                        status: 'Thinking',
                        systemMessageSeverity: null
                    };

                    if (!chats[randomChatId]) {
                        chats[randomChatId] = {
                            randomChatId: randomChatId,
                            messages: [],
                            status: 'Processing'
                        };
                    }

                    chats[randomChatId].messages.push(messageModel);
                    renderChat(chats[randomChatId]);

                    // Convert audio data to byte array
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const byteArray = new Uint8Array(arrayBuffer);

                    connection.invoke('SendAudio', randomChatId, randomMessageId, byteArray)
                        .catch(err => {
                            console.error('SendAudio error:', err.toString());
                        });
                } catch (err) {
                    console.error('Error in startVoiceRecording:', err);
                }
            };

            const tryCancelMessage = (randomChatId, randomMessageId) => {
                try {
                    connection.invoke('TryCancel', randomMessageId, randomChatId)
                        .catch(err => {
                            console.error('TryCancel error:', err.toString());
                        });
                } catch (err) {
                    console.error('Error in tryCancelMessage:', err);
                }
            };

            const closeChat = (randomChatId) => {
                try {
                    connection.invoke('CloseChat', randomChatId)
                        .catch(err => {
                            console.error('CloseChat error:', err.toString());
                        });
                } catch (err) {
                    console.error('Error in closeChat:', err);
                }
            };

            const generateRandomId = () => {
                // Simple function to generate a random ID
                return 'id-' + Math.random().toString(36).substr(2, 9);
            };

            // Define recordAudio here or ensure it's defined before use
            const recordAudio = () => {
                return new Promise(async (resolve, reject) => {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const mediaRecorder = new MediaRecorder(stream);
                        const audioChunks = [];

                        mediaRecorder.ondataavailable = event => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            resolve(audioBlob);
                        };

                        mediaRecorder.start();

                        // Stop recording after 5 seconds or implement your own logic
                        setTimeout(() => {
                            mediaRecorder.stop();
                        }, 5000);
                    } catch (err) {
                        console.error('Error recording audio:', err);
                        reject(err);
                    }
                });
            };

            const newChatButtonHandler = () => {
                try {
                    const randomChatId = generateRandomId();
                    chats[randomChatId] = {
                        randomChatId: randomChatId,
                        messages: [],
                        status: 'Success' // or 'Processing' based on your logic
                    };
                    renderChat(chats[randomChatId]);
                } catch (err) {
                    console.error('Error starting a new chat:', err);
                }
            };

            newChatButton.addEventListener('click', newChatButtonHandler);

            const logError = (message, error) => {
                console.error(message, error);
            };

            const logInfo = (message, info) => {
                console.info(message, info);
            };

            // Initialize the connection
            initializeConnection();
        })();
    </script>

    <style>
        .chat {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

            .chat h3 {
                margin-top: 0;
            }

        .messageInput {
            width: 70%;
            padding: 5px;
        }

        .sendButton, .micButton {
            margin-left: 5px;
            padding: 5px 10px;
        }

        #connectionStatus {
            font-weight: bold;
            margin-bottom: 10px;
        }

            #connectionStatus span {
                color: red;
            }

                #connectionStatus span.connected {
                    color: green;
                }

                #connectionStatus span.reconnecting {
                    color: orange;
                }

        #newChatContainer {
            margin-bottom: 20px;
        }

        .system-message {
            color: gray;
            font-style: italic;
        }

        .own-message {
            color: blue;
        }
    </style>
}
