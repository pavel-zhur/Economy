@page
@model ChatModel
@{
    ViewData["Title"] = "Chat";
}

<h2>Chat Application</h2>

<div id="connectionStatus">Status: <span id="statusText" class="disconnected">Disconnected</span></div>

<div id="chatsContainer"></div>

<div id="newChatContainer">
    <button id="newChatButton">Start New Chat</button>
</div>

@section Scripts {
    <script>
        (() => {
            const connectionStatusText = document.getElementById('statusText');
            const chatsContainer = document.getElementById('chatsContainer');
            const newChatButton = document.getElementById('newChatButton');

            let chats = {}; // Stores server chats with randomChatId as the key
            let localChats = {}; // Stores local chats with 0 or 1 unsent message
            let pendingMessages = {}; // Stores pending messages per chat
            let connection;

            // Global error handlers
            window.onerror = function(message, source, lineno, colno, error) {
                console.error(`Global Error: ${message} at ${source}:${lineno}:${colno}`, error);
            };

            window.onunhandledrejection = function(event) {
                console.error('Unhandled Promise Rejection:', event.reason);
            };

            const initializeConnection = () => {
                try {
                    connection = new signalR.HubConnectionBuilder()
                        .withUrl("/chathub")
                        .withHubProtocol(new signalR.protocols.msgpack.MessagePackHubProtocol())
                        .withAutomaticReconnect({
                            nextRetryDelayInMilliseconds: retryContext => {
                                if (retryContext.elapsedMilliseconds < 60000) {
                                    // Wait between 0 and 3 seconds before the next reconnect attempt.
                                    return Math.random() * 3000;
                                } else {
                                    // Stop reconnecting after 60 seconds
                                    return null;
                                }
                            }
                        })
                        .configureLogging(signalR.LogLevel.Information)
                        .build();

                    // Event handlers
                    connection.onclose(error => {
                        handleConnectionClose(error);
                    });

                    connection.onreconnecting(error => {
                        handleConnectionReconnecting(error);
                    });

                    connection.onreconnected(connectionId => {
                        handleConnectionReconnected(connectionId);
                    });

                    connection.on('HelloResponse', state => {
                        handleHelloResponse(state);
                    });

                    connection.on('Authenticate', () => {
                        try {
                            // Server demands reauthentication; reload the page
                            location.reload();
                        } catch (err) {
                            console.error('Error in Authenticate handler:', err);
                        }
                    });

                    // Start the connection
                    updateConnectionStatus('Reconnecting');
                    connection.start()
                        .then(() => {
                            updateConnectionStatus('Connected');
                            disableInputs(false);
                            console.info('SignalR connection established.');
                            sendHello();
                        })
                        .catch(err => {
                            console.error('Connection error:', err.toString());
                        });
                } catch (err) {
                    console.error('Error initializing SignalR connection:', err);
                }
            };

            const handleConnectionClose = (error) => {
                try {
                    updateConnectionStatus('Disconnected');
                    disableInputs(true);
                    logError('Connection closed', error);
                } catch (err) {
                    console.error('Error in handleConnectionClose:', err);
                }
            };

            const handleConnectionReconnecting = (error) => {
                try {
                    updateConnectionStatus('Reconnecting');
                    disableInputs(true);
                    logError('Connection reconnecting', error);
                } catch (err) {
                    console.error('Error in handleConnectionReconnecting:', err);
                }
            };

            const handleConnectionReconnected = (connectionId) => {
                try {
                    updateConnectionStatus('Connected');
                    disableInputs(false);
                    sendHello();
                    logInfo('Reconnected with connectionId:', connectionId);
                } catch (err) {
                    console.error('Error in handleConnectionReconnected:', err);
                }
            };

            const handleHelloResponse = (state) => {
                try {
                    // Merge server chats with local chats
                    const serverChats = {};
                    state.chats.forEach(chatModel => {
                        serverChats[chatModel.randomChatId] = chatModel;
                        // Remove from localChats if exists
                        if (localChats[chatModel.randomChatId]) {
                            delete localChats[chatModel.randomChatId];
                        }

                        // Clear pending messages if they exist in the new model
                        chatModel.messages.forEach(message => {
                            if (pendingMessages[chatModel.randomChatId] && pendingMessages[chatModel.randomChatId].messageModel.randomMessageId === message.randomMessageId) {
                                delete pendingMessages[chatModel.randomChatId];
                            }
                        });
                    });
                    chats = { ...serverChats };
                    renderChats();
                } catch (err) {
                    console.error('Error handling HelloResponse:', err);
                }
            };

            const updateConnectionStatus = (status) => {
                try {
                    connectionStatusText.textContent = status;
                    const statusClass = status.toLowerCase();
                    connectionStatusText.className = ''; // Reset classes
                    connectionStatusText.classList.add(statusClass);
                } catch (err) {
                    console.error('Error updating connection status:', err);
                }
            };

            const sendHello = () => {
                connection.invoke('Hello')
                    .catch(err => {
                        console.error('Error sending Hello:', err.toString());
                    });
            };

            const disableInputs = (disabled) => {
                try {
                    const sendButtons = document.querySelectorAll('.sendButton');
                    const micButtons = document.querySelectorAll('.micButton');
                    sendButtons.forEach(button => button.disabled = disabled);
                    micButtons.forEach(button => button.disabled = disabled);
                } catch (err) {
                    console.error('Error disabling inputs:', err);
                }
            };

            const renderChats = () => {
                try {
                    // Preserve input values
                    const inputValues = {};
                    Object.keys(localChats).forEach(chatId => {
                        const input = document.getElementById(`messageInput-${chatId}`);
                        if (input) {
                            inputValues[chatId] = input.value;
                        }
                    });

                    // Combine server and local chats
                    const allChats = [
                        ...Object.values(chats),
                        ...Object.values(localChats)
                            ];

                    // Sort: server chats first based on server order, then local chats by creation
                    allChats.sort((a, b) => {
                        if (chats[a.randomChatId] && chats[b.randomChatId]) {
                            return 0; // Maintain server order
                        }
                        if (chats[a.randomChatId]) return -1;
                        if (chats[b.randomChatId]) return 1;
                        return 0;
                    });

                    // Clear existing chats
                    chatsContainer.innerHTML = '';
                    allChats.forEach(chatModel => {
                        renderChat(chatModel);
                    });

                    // Restore input values
                    Object.keys(inputValues).forEach(chatId => {
                        const input = document.getElementById(`messageInput-${chatId}`);
                        if (input) {
                            input.value = inputValues[chatId];
                        }
                    });

                    // Render pending messages
                    Object.values(pendingMessages).forEach(pending => {
                        renderPendingMessage(pending);
                    });
                } catch (err) {
                    console.error('Error rendering chats:', err);
                }
            };

            const renderChat = (chatModel) => {
                try {
                    let chatDiv = document.getElementById(`chat-${chatModel.randomChatId}`);
                    if (!chatDiv) {
                        chatDiv = document.createElement('div');
                        chatDiv.id = `chat-${chatModel.randomChatId}`;
                        chatDiv.classList.add('chat');

                        const chatHeader = document.createElement('h3');
                        chatHeader.textContent = `Chat ${chatModel.randomChatId}`;
                        chatDiv.appendChild(chatHeader);

                        const messagesList = document.createElement('ul');
                        messagesList.id = `messagesList-${chatModel.randomChatId}`;
                        chatDiv.appendChild(messagesList);

                        const messageInput = document.createElement('input');
                        messageInput.type = 'text';
                        messageInput.placeholder = 'Type a message...';
                        messageInput.classList.add('messageInput');
                        messageInput.id = `messageInput-${chatModel.randomChatId}`;
                        chatDiv.appendChild(messageInput);

                        const sendButton = createButton('Send', `sendButton-${chatModel.randomChatId}`, () => {
                            try {
                                sendMessage(chatModel.randomChatId);
                            } catch (err) {
                                console.error('Error in sendButton click handler:', err);
                            }
                        });
                        chatDiv.appendChild(sendButton);

                        const micButton = createButton('🔊', `micButton-${chatModel.randomChatId}`, () => {
                            try {
                                startVoiceRecording(chatModel.randomChatId);
                            } catch (err) {
                                console.error('Error in micButton click handler:', err);
                            }
                        });
                        chatDiv.appendChild(micButton);

                        const closeChatButton = createButton('Close Chat', null, () => {
                            try {
                                closeChat(chatModel.randomChatId);
                            } catch (err) {
                                console.error('Error in closeChatButton click handler:', err);
                            }
                        });
                        chatDiv.appendChild(closeChatButton);

                        chatsContainer.appendChild(chatDiv);
                    }

                    updateChatUI(chatModel);
                } catch (err) {
                    console.error('Error rendering a chat:', err);
                }
            };

            const createButton = (text, id, onClick) => {
                const button = document.createElement('button');
                button.textContent = text;
                if (id) button.id = id;
                button.classList.add('sendButton'); // Adjust class if needed
                button.addEventListener('click', onClick);
                return button;
            };

            const renderPendingMessage = (pending) => {
                try {
                    const { randomChatId, messageModel } = pending;
                    let chatDiv = document.getElementById(`chat-${randomChatId}`);
                    if (!chatDiv) return;

                    let messagesList = document.getElementById(`messagesList-${randomChatId}`);
                    if (!messagesList) return;

                    const li = document.createElement('li');
                    li.id = `message-${messageModel.randomMessageId}`;
                    li.textContent = `${messageModel.type === 'UserText' ? 'You' : 'You (Audio)'}: ${messageModel.text} - ${messageModel.status}`;

                    const resendButton = createButton('Resend', null, () => {
                        try {
                            resendMessage(randomChatId, messageModel.randomMessageId, messageModel.text, messageModel.type);
                        } catch (err) {
                            console.error('Error in resend button click handler:', err);
                        }
                    });
                    li.appendChild(resendButton);

                    messagesList.appendChild(li);
                } catch (err) {
                    console.error('Error rendering pending message:', err);
                }
            };

            const updateChatUI = (chatModel) => {
                try {
                    const messagesList = document.getElementById(`messagesList-${chatModel.randomChatId}`);
                    if (messagesList) {
                        messagesList.innerHTML = '';
                        chatModel.messages.forEach(message => {
                            const li = document.createElement('li');
                            li.id = `message-${message.randomMessageId}`;
                            li.textContent = formatMessage(message);

                            // Add cancel button for user's message if cancellation is possible
                            if ((message.type === 'UserText' || message.type === 'UserVoice') && message.status === 'Thinking') {
                                const cancelButton = createButton('Cancel', null, () => {
                                    try {
                                        tryCancelMessage(chatModel.randomChatId, message.randomMessageId);
                                    } catch (err) {
                                        console.error('Error in cancel button click handler:', err);
                                    }
                                });
                                li.appendChild(cancelButton);
                            }

                            messagesList.appendChild(li);
                        });
                        messagesList.scrollTop = messagesList.scrollHeight;
                    }

                    // Determine if inputs should be disabled based on chat status
                    const { status } = chatModel;
                    const shouldDisable = status === 'FatalError';
                    const sendButton = document.getElementById(`sendButton-${chatModel.randomChatId}`);
                    const micButton = document.getElementById(`micButton-${chatModel.randomChatId}`);
                    const messageInput = document.getElementById(`messageInput-${chatModel.randomChatId}`);

                    if (sendButton) sendButton.disabled = shouldDisable;
                    if (micButton) micButton.disabled = shouldDisable;
                    if (messageInput) {
                        messageInput.disabled = shouldDisable;
                        if (status === 'Normal') {
                            messageInput.disabled = false;
                        }
                    }
                } catch (err) {
                    console.error('Error updating chat UI:', err);
                }
            };

            const formatMessage = (message) => {
                try {
                    let msgText = '';
                    if (message.type === 'UserText') {
                        msgText = `You: ${message.text} - ${message.status}`;
                    } else if (message.type === 'UserVoice') {
                        msgText = `You (Audio): Transcription - ${message.text} - ${message.status}`;
                        // Optionally, display audio playback if audioData exists
                    } else if (message.type === 'ServerText') {
                        msgText = `Server: ${message.text}`;
                    } else if (message.type === 'SystemText') {
                        msgText = `[${message.systemMessageSeverity}] ${message.text}`;
                    } else if (message.type === 'ActionLog') {
                        msgText = `${message.text}`;
                    }
                    return msgText;
                } catch (err) {
                    console.error('Error formatting message:', err);
                    return 'Invalid message format';
                }
            };

            const sendMessage = (randomChatId) => {
                try {
                    const messageInput = document.getElementById(`messageInput-${randomChatId}`);
                    const messageText = messageInput.value.trim();
                    if (messageText === '') return;

                    const randomMessageId = generateRandomId();

                    // Disable buttons in the chat
                    toggleChatButtons(randomChatId, true);

                    // Optimistically add message to local chats
                    if (!chats[randomChatId] && !localChats[randomChatId]) {
                        localChats[randomChatId] = {
                            randomChatId: randomChatId,
                            messages: [],
                            status: 'Local'
                        };
                    }

                    const messageModel = {
                        timestamp: new Date().toISOString(),
                        type: 'UserText',
                        randomMessageId: randomMessageId,
                        text: messageText,
                        status: 'Sending',
                        systemMessageSeverity: null
                    };

                    (localChats[randomChatId] || chats[randomChatId]).messages.push(messageModel);
                    renderChats();

                    // Add to pending messages
                    pendingMessages[randomChatId] = {
                        randomChatId: randomChatId,
                        messageModel: messageModel
                    };

                    // Send the message to the server
                    connection.invoke('SendMessage', randomChatId, randomMessageId, messageText)
                        .then(() => {
                            // Update message status upon successful send
                            if (localChats[randomChatId]) {
                                const msg = localChats[randomChatId].messages.find(m => m.randomMessageId === randomMessageId);
                                if (msg) msg.status = 'Sent';
                                renderChats();
                            }
                        })
                        .catch(err => {
                            console.error('SendMessage error:', err.toString());
                            if (localChats[randomChatId]) {
                                const msg = localChats[randomChatId].messages.find(m => m.randomMessageId === randomMessageId);
                                if (msg) msg.status = 'Failed';
                                renderChats();
                            }
                        })
                        .finally(() => {
                            // Re-enable buttons
                            toggleChatButtons(randomChatId, false);
                        });

                    // Clear the message input after sending
                    messageInput.value = '';
                } catch (err) {
                    console.error('Error in sendMessage:', err);
                }
            };

            const resendMessage = (randomChatId, randomMessageId, text, type) => {
                try {
                    // Remove existing pending message
                    delete pendingMessages[randomChatId];

                    // Update message status
                    const chat = localChats[randomChatId];
                    if (chat) {
                        const msg = chat.messages.find(m => m.randomMessageId === randomMessageId);
                        if (msg) {
                            msg.status = 'Sending';
                            renderChats();

                            // Re-invoke send based on message type
                            if (type === 'UserText') {
                                connection.invoke('SendMessage', randomChatId, randomMessageId, text)
                                    .then(() => {
                                        msg.status = 'Sent';
                                        renderChats();
                                    })
                                    .catch(err => {
                                        console.error('Resend SendMessage error:', err.toString());
                                        msg.status = 'Failed';
                                        renderChats();
                                    });
                            } else if (type === 'UserVoice') {
                                // Use stored audioData for resend
                                if (msg.audioData) {
                                    connection.invoke('SendAudio', randomChatId, randomMessageId, msg.audioData)
                                        .then(() => {
                                            msg.status = 'Sent';
                                            renderChats();
                                        })
                                        .catch(err => {
                                            console.error('Resend SendAudio error:', err.toString());
                                            msg.status = 'Failed';
                                            renderChats();
                                        });
                                } else {
                                    console.error('No audio data available for resend.');
                                    msg.status = 'Failed';
                                    renderChats();
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.error('Error in resendMessage:', err);
                }
            };

            const startVoiceRecording = async (randomChatId) => {
                try {
                    // Disable buttons during recording
                    toggleChatButtons(randomChatId, true);

                    // Start voice recording
                    const audioBlob = await recordAudio(randomChatId);
                    const randomMessageId = generateRandomId();

                    // Check if a pending message already exists
                    if (pendingMessages[randomChatId]) return;

                    // Convert audio data to byte array
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const byteArray = new Uint8Array(arrayBuffer);

                    // Optimistically add audio message to local chats
                    if (!localChats[randomChatId]) {
                        localChats[randomChatId] = {
                            randomChatId: randomChatId,
                            messages: [],
                            status: 'Local'
                        };
                    }

                    const messageModel = {
                        timestamp: new Date().toISOString(),
                        type: 'UserVoice',
                        randomMessageId: randomMessageId,
                        text: "(Audio)",
                        status: 'Sending',
                        systemMessageSeverity: null,
                        audioData: byteArray // Storing audio data for retry
                    };

                    localChats[randomChatId].messages.push(messageModel);
                    renderChats();

                    // Add to pending messages
                    pendingMessages[randomChatId] = {
                        randomChatId: randomChatId,
                        messageModel: messageModel
                    };

                    // Send the audio message to the server
                    connection.invoke('SendAudio', randomChatId, randomMessageId, byteArray)
                        .then(() => {
                            // Update message status upon successful send
                            if (localChats[randomChatId]) {
                                const msg = localChats[randomChatId].messages.find(m => m.randomMessageId === randomMessageId);
                                if (msg) msg.status = 'Sent';
                                renderChats();
                            }
                        })
                        .catch(err => {
                            console.error('SendAudio error:', err.toString());
                            if (localChats[randomChatId]) {
                                const msg = localChats[randomChatId].messages.find(m => m.randomMessageId === randomMessageId);
                                if (msg) msg.status = 'Failed';
                                renderChats();
                            }
                        })
                        .finally(() => {
                            // Re-enable buttons
                            toggleChatButtons(randomChatId, false);
                        });
                } catch (err) {
                    console.error('Error in startVoiceRecording:', err);
                }
            };

            const tryCancelMessage = (randomChatId, randomMessageId) => {
                try {
                    connection.invoke('TryCancel', randomMessageId, randomChatId)
                        .catch(err => {
                            console.error('TryCancel error:', err.toString());
                        });
                } catch (err) {
                    console.error('Error in tryCancelMessage:', err);
                }
            };

            const closeChat = (randomChatId) => {
                try {
                    // Remove from server and local chats
                    delete chats[randomChatId];
                    delete localChats[randomChatId];
                    delete pendingMessages[randomChatId];
                    renderChats();

                    // Optionally notify the server
                    connection.invoke('CloseChat', randomChatId)
                        .catch(err => {
                            console.error('CloseChat error:', err.toString());
                        });
                } catch (err) {
                    console.error('Error in closeChat:', err);
                }
            };

            const toggleChatButtons = (randomChatId, disable) => {
                try {
                    const sendButton = document.getElementById(`sendButton-${randomChatId}`);
                    const micButton = document.getElementById(`micButton-${randomChatId}`);
                    const messageInput = document.getElementById(`messageInput-${randomChatId}`);
                    if (sendButton) sendButton.disabled = disable;
                    if (micButton) micButton.disabled = disable;
                    if (messageInput) messageInput.disabled = disable;
                } catch (err) {
                    console.error('Error toggling chat buttons:', err);
                }
            };

            const generateRandomId = () => {
                // Simple function to generate a random ID
                return 'id-' + Math.random().toString(36).substr(2, 9);
            };

            const recordAudio = (randomChatId) => {
                return new Promise(async (resolve, reject) => {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const mediaRecorder = new MediaRecorder(stream);
                        const audioChunks = [];

                        mediaRecorder.ondataavailable = event => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            resolve(audioBlob);
                            // Stop all tracks to release the microphone
                            stream.getTracks().forEach(track => track.stop());
                        };

                        mediaRecorder.start();

                        // Stop recording after 5 seconds or implement your own logic
                        setTimeout(() => {
                            if (mediaRecorder.state !== 'inactive') {
                                mediaRecorder.stop();
                            }
                        }, 5000);
                    } catch (err) {
                        console.error('Error recording audio:', err);
                        reject(err);
                    }
                });
            };

            const newChatButtonHandler = () => {
                try {
                    const randomChatId = generateRandomId();
                    localChats[randomChatId] = {
                        randomChatId: randomChatId,
                        messages: [],
                        status: 'Local'
                    };
                    renderChats();
                } catch (err) {
                    console.error('Error starting a new chat:', err);
                }
            };

            newChatButton.addEventListener('click', newChatButtonHandler);

            const logError = (message, error) => {
                console.error(message, error);
            };

            const logInfo = (message, info) => {
                console.info(message, info);
            };

            // Initialize the connection
            initializeConnection();
        })();
    </script>

    <style>
        .chat {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

            .chat h3 {
                margin-top: 0;
            }

        .messageInput {
            width: 70%;
            padding: 5px;
        }

        .sendButton, .micButton {
            margin-left: 5px;
            padding: 5px 10px;
        }

        #connectionStatus {
            font-weight: bold;
            margin-bottom: 10px;
        }

            #connectionStatus span {
                color: red;
            }

                #connectionStatus span.connected {
                    color: green;
                }

                #connectionStatus span.reconnecting {
                    color: orange;
                }

        #newChatContainer {
            margin-bottom: 20px;
        }

        .system-message {
            color: gray;
            font-style: italic;
        }

        .own-message {
            color: blue;
        }
    </style>
}
